{"expireTime":9007200868107414000,"key":"transformer-remark-markdown-html-ast-64288628ddcda8765371cb8767144bbd--","val":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I spent a long time trying to get the BLE functionality to work, but no success on that branch so far. So in order to avoid letting my ego roll into a pit of despair, I decided to take a break and do something much easier: add in all the sensor readings. ","position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":256,"offset":256}}}],"position":{"start":{"line":2,"column":1,"offset":1},"end":{"line":2,"column":256,"offset":256}}},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Before I could do that, I needed to create a function that lets me print floats over usb, by converting a ","position":{"start":{"line":4,"column":1,"offset":258},"end":{"line":4,"column":107,"offset":364}}},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"float"}],"position":{"start":{"line":4,"column":107,"offset":364},"end":{"line":4,"column":114,"offset":371}}},{"type":"text","value":" to a ","position":{"start":{"line":4,"column":114,"offset":371},"end":{"line":4,"column":120,"offset":377}}},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"char*"}],"position":{"start":{"line":4,"column":120,"offset":377},"end":{"line":4,"column":127,"offset":384}}},{"type":"text","value":". Looking around online, the answer seemed to be using ","position":{"start":{"line":4,"column":127,"offset":384},"end":{"line":4,"column":182,"offset":439}}},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"snprintf"}],"position":{"start":{"line":4,"column":182,"offset":439},"end":{"line":4,"column":192,"offset":449}}},{"type":"text","value":". However, I tried using this function to do just that but did not succeed. I then tried compiling this with clang, and I was able to get it working. Hmm! Turns out, not all compilers will support float with ","position":{"start":{"line":4,"column":192,"offset":449},"end":{"line":4,"column":400,"offset":657}}},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"snprintf"}],"position":{"start":{"line":4,"column":400,"offset":657},"end":{"line":4,"column":410,"offset":667}}},{"type":"text","value":", as was the case here. So instead, I had to create a function from scratch myself. Probably not the nicest looking function, but here it is. Check out the repo for more details, should be there as of commit e9492087f8389e4e541dcfb5e9cae6c7b8aa36b1.","position":{"start":{"line":4,"column":410,"offset":667},"end":{"line":4,"column":659,"offset":916}}}],"position":{"start":{"line":4,"column":1,"offset":258},"end":{"line":4,"column":659,"offset":916}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-cpp"]},"children":[{"type":"text","value":"#include \"sx_util.h\"\n\nvoid usbprint_float(float value, int precision)\n{\n    int integer_pt = value;\n    volatile float fraction = (value-integer_pt)*pow(10,precision);\n    int fraction_pt = fraction;\n\n    // count number of digits\n    volatile int count_int = 0;\n    volatile int count_fract = 0;\n    int n = integer_pt;\n    while (n != 0) {\n        n /= 10;  \n        ++count_int;\n    }\n    n = fraction_pt;\n    while (n != 0) {\n        n /= 10;  \n        ++count_fract;\n    }\n\n    // Convert integer and fraction parts to char buffers\n    char int_buf[16];                        // NOTE: MAX integer length of 16\n    char fract_buf[16];                      // NOTE: MAX decimal length of 16\n\n    snprintf(int_buf,10,\"%d\",integer_pt);\n    snprintf(fract_buf,10,\"%d\",fraction_pt);\n\n    // Add on the decimal point\n    strcat(int_buf,\".\");\n    // Add the newline\n    strcat(fract_buf,\"\\n\");\n\n    char outStr[16];\n    // Put the characters into the array\n    for(int i=0;i<count_int+1;i++){\n        outStr[i] = int_buf[i];\n    }\n    for(int i=0;i<=count_fract+1;i++){\n        outStr[count_int+1+i] = fract_buf[i];\n    }\n\n    usb_print((uint8_t*)outStr,count_int+count_fract+2);\n    \n}\n"}],"position":{"start":{"line":6,"column":1,"offset":918},"end":{"line":53,"column":4,"offset":2113}}}],"position":{"start":{"line":6,"column":1,"offset":918},"end":{"line":53,"column":4,"offset":2113}}},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Finally, all I had to do was create a Sensors class that initialized all the sensors on the constructor.","position":{"start":{"line":55,"column":1,"offset":2115},"end":{"line":55,"column":105,"offset":2219}}}],"position":{"start":{"line":55,"column":1,"offset":2115},"end":{"line":55,"column":105,"offset":2219}}},{"type":"text","value":"\n"},{"type":"element","tagName":"pre","properties":{},"children":[{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"Temperature Reading: 25.1\nHumidity Reading: 57.27\nPressure Reading: 1013.70\nAccel X: 5.0, Y: 413.0, Z: 916.0\nGyro X: 210.0, Y: -14000, Z: 350.0\nMagneto X: 672.0, Y: -4200, Z: -4290\n"}],"position":{"start":{"line":56,"column":1,"offset":2220},"end":{"line":63,"column":4,"offset":2408}}}],"position":{"start":{"line":56,"column":1,"offset":2220},"end":{"line":63,"column":4,"offset":2408}}},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Sensor readings all seem to come out fine, though I'm not totally sure what the units on the gyro, magneto are. I'll take a look another time. Time to get back to banging my head on the BLE first, QSPI next.","position":{"start":{"line":65,"column":1,"offset":2410},"end":{"line":65,"column":208,"offset":2617}}}],"position":{"start":{"line":65,"column":1,"offset":2410},"end":{"line":65,"column":208,"offset":2617}}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":65,"column":208,"offset":2617}}}}