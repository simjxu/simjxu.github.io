{"expireTime":9007200877953585000,"key":"transformer-remark-markdown-html-12a7bc3ce785029139745c8f9c2c3eb9--","val":"<p>I spent a long time trying to get the BLE functionality to work, but no success on that branch so far. So in order to avoid letting my ego roll into a pit of despair, I decided to take a break and do something much easier: add in all the sensor readings. </p>\n<p>Before I could do that, I needed to create a function that lets me print floats over usb, by converting a <code>float</code> to a <code>char*</code>. Looking around online, the answer seemed to be using <code>snprintf</code>. However, I tried using this function to do just that but did not succeed. I then tried compiling this with clang, and I was able to get it working. Hmm! Turns out, not all compilers will support float with <code>snprintf</code>, as was the case here. So instead, I had to create a function from scratch myself. Probably not the nicest looking function, but here it is. Check out the repo for more details, should be there as of commit e9492087f8389e4e541dcfb5e9cae6c7b8aa36b1.</p>\n<pre><code class=\"language-cpp\">#include \"sx_util.h\"\n\nvoid usbprint_float(float value, int precision)\n{\n    int integer_pt = value;\n    volatile float fraction = (value-integer_pt)*pow(10,precision);\n    int fraction_pt = fraction;\n\n    // count number of digits\n    volatile int count_int = 0;\n    volatile int count_fract = 0;\n    int n = integer_pt;\n    while (n != 0) {\n        n /= 10;  \n        ++count_int;\n    }\n    n = fraction_pt;\n    while (n != 0) {\n        n /= 10;  \n        ++count_fract;\n    }\n\n    // Convert integer and fraction parts to char buffers\n    char int_buf[16];                        // NOTE: MAX integer length of 16\n    char fract_buf[16];                      // NOTE: MAX decimal length of 16\n\n    snprintf(int_buf,10,\"%d\",integer_pt);\n    snprintf(fract_buf,10,\"%d\",fraction_pt);\n\n    // Add on the decimal point\n    strcat(int_buf,\".\");\n    // Add the newline\n    strcat(fract_buf,\"\\n\");\n\n    char outStr[16];\n    // Put the characters into the array\n    for(int i=0;i&#x3C;count_int+1;i++){\n        outStr[i] = int_buf[i];\n    }\n    for(int i=0;i&#x3C;=count_fract+1;i++){\n        outStr[count_int+1+i] = fract_buf[i];\n    }\n\n    usb_print((uint8_t*)outStr,count_int+count_fract+2);\n    \n}\n</code></pre>\n<p>Finally, all I had to do was create a Sensors class that initialized all the sensors on the constructor.</p>\n<pre><code>Temperature Reading: 25.1\nHumidity Reading: 57.27\nPressure Reading: 1013.70\nAccel X: 5.0, Y: 413.0, Z: 916.0\nGyro X: 210.0, Y: -14000, Z: 350.0\nMagneto X: 672.0, Y: -4200, Z: -4290\n</code></pre>\n<p>Sensor readings all seem to come out fine, though I'm not totally sure what the units on the gyro, magneto are. I'll take a look another time. Time to get back to banging my head on the BLE first, QSPI next.</p>"}